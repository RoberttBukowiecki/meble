'use client';

/**
 * CabinetResizeControls Component
 *
 * Renders 6 resize handles on cabinet bounding box.
 * Uses GENERATOR-BASED preview - same logic as PropertiesPanel for consistency.
 *
 * PERFORMANCE STRATEGY:
 * - dragStateRef stores mutable state during drag
 * - Generator creates preview parts with new dimensions
 * - RAF throttle ensures smooth updates
 * - Store updated ONCE on pointerup
 */

import { useRef, useCallback, useEffect, useState, useMemo } from 'react';
import { useThree, ThreeEvent } from '@react-three/fiber';
import { Html } from '@react-three/drei';
import * as THREE from 'three';
import { useStore, useMaterial } from '@/lib/store';
import { useShallow } from 'zustand/react/shallow';
import type { Part, CabinetResizeHandle, CabinetBoundingBox, CabinetParams } from '@/types';
import { PART_CONFIG, MATERIAL_CONFIG } from '@/lib/config';
import { getGeneratorForType } from '@/lib/cabinetGenerators';
import { getCabinetTransform, applyCabinetTransform, getDefaultBackMaterial } from '@/lib/store/utils';
import {
  calculateCabinetBoundingBox,
  getCabinetHandlePosition,
  getCabinetHandleNormal,
  getHandleAxisIndex,
  isPositiveHandle,
  getHandleAxisName,
} from '@/lib/cabinetResize';

// ============================================================================
// Constants
// ============================================================================

const HANDLE_SIZE = 25;
const HITBOX_SIZE = 60;
const MIN_DIMENSION = 50;
const GRID_SNAP = 10;

const HANDLES: CabinetResizeHandle[] = [
  'width+', 'width-',
  'height+', 'height-',
  'depth+', 'depth-',
];

// ============================================================================
// Types
// ============================================================================

interface CabinetResizeControlsProps {
  cabinetId: string;
  onTransformStart: () => void;
  onTransformEnd: () => void;
}

interface DragState {
  isDragging: boolean;
  handle: CabinetResizeHandle | null;
  startPoint: THREE.Vector3;
  initialBoundingBox: CabinetBoundingBox;
  initialCenter: THREE.Vector3;
  initialRotation: THREE.Quaternion;
  // Preview parts generated by the generator
  previewParts: Omit<Part, 'id' | 'createdAt' | 'updatedAt'>[];
  previewBoundingBox: CabinetBoundingBox | null;
  newParams: CabinetParams | null;
  centerOffset: [number, number, number] | null;
}

// ============================================================================
// Handle Mesh Component
// ============================================================================

interface HandleMeshProps {
  boundingBox: CabinetBoundingBox;
  handle: CabinetResizeHandle;
  isActive: boolean;
  isHovered: boolean;
  onPointerDown: (e: ThreeEvent<PointerEvent>, handle: CabinetResizeHandle) => void;
  onPointerEnter: (handle: CabinetResizeHandle) => void;
  onPointerLeave: () => void;
}

function HandleMesh({
  boundingBox,
  handle,
  isActive,
  isHovered,
  onPointerDown,
  onPointerEnter,
  onPointerLeave,
}: HandleMeshProps) {
  const position = useMemo(
    () => getCabinetHandlePosition(boundingBox, handle),
    [boundingBox, handle]
  );
  const normal = useMemo(() => getCabinetHandleNormal(handle), [handle]);

  const rotation = useMemo(() => {
    const up = new THREE.Vector3(0, 1, 0);
    const dir = new THREE.Vector3(...normal);
    const quaternion = new THREE.Quaternion().setFromUnitVectors(up, dir);
    const euler = new THREE.Euler().setFromQuaternion(quaternion);
    return [euler.x, euler.y, euler.z] as [number, number, number];
  }, [normal]);

  const color = useMemo(() => {
    if (isActive) return PART_CONFIG.RESIZE_HANDLE_ACTIVE_COLOR;
    if (isHovered) return PART_CONFIG.RESIZE_HANDLE_HOVER_COLOR;
    return PART_CONFIG.RESIZE_HANDLE_COLOR;
  }, [isActive, isHovered]);

  const emissiveIntensity = useMemo(() => {
    if (isActive) return PART_CONFIG.RESIZE_HANDLE_ACTIVE_EMISSIVE_INTENSITY;
    if (isHovered) return PART_CONFIG.RESIZE_HANDLE_HOVER_EMISSIVE_INTENSITY;
    return PART_CONFIG.RESIZE_HANDLE_EMISSIVE_INTENSITY;
  }, [isActive, isHovered]);

  const scale = isActive || isHovered ? 1.2 : 1;

  return (
    <group position={position} rotation={rotation}>
      <mesh
        onPointerDown={(e) => onPointerDown(e, handle)}
        onPointerEnter={() => onPointerEnter(handle)}
        onPointerLeave={onPointerLeave}
      >
        <boxGeometry args={[HITBOX_SIZE, 5, HITBOX_SIZE]} />
        <meshBasicMaterial visible={false} />
      </mesh>
      <mesh scale={scale}>
        <boxGeometry args={[HANDLE_SIZE, 5, HANDLE_SIZE]} />
        <meshStandardMaterial
          color={color}
          emissive={color}
          emissiveIntensity={emissiveIntensity}
        />
      </mesh>
    </group>
  );
}

// ============================================================================
// Preview Mesh Component
// ============================================================================

interface PreviewMeshProps {
  part: Omit<Part, 'id' | 'createdAt' | 'updatedAt'>;
}

function PreviewMesh({ part }: PreviewMeshProps) {
  const material = useMaterial(part.materialId);
  const color = material?.color || MATERIAL_CONFIG.DEFAULT_MATERIAL_COLOR;

  return (
    <mesh
      position={part.position}
      rotation={part.rotation}
      castShadow
      receiveShadow
    >
      <boxGeometry args={[part.width, part.height, part.depth]} />
      <meshStandardMaterial
        color={color}
        emissive={PART_CONFIG.SELECTION_EMISSIVE_COLOR}
        emissiveIntensity={PART_CONFIG.SELECTION_EMISSIVE_INTENSITY}
      />
    </mesh>
  );
}

// ============================================================================
// Dimension Display Component
// ============================================================================

interface DimensionDisplayProps {
  boundingBox: CabinetBoundingBox;
  activeHandle: CabinetResizeHandle;
}

function DimensionDisplay({ boundingBox, activeHandle }: DimensionDisplayProps) {
  const axis = getHandleAxisName(activeHandle);
  const axisIndex = getHandleAxisIndex(activeHandle);
  const dimension = boundingBox.size[axisIndex];

  const labelPosition = getCabinetHandlePosition(boundingBox, activeHandle);
  const offsetPos: [number, number, number] = [
    labelPosition[0],
    labelPosition[1] + 50,
    labelPosition[2],
  ];

  const labels: Record<string, string> = {
    width: 'Szerokość',
    height: 'Wysokość',
    depth: 'Głębokość',
  };

  return (
    <Html position={offsetPos} center>
      <div className="pointer-events-none rounded bg-background/90 px-3 py-1.5 text-sm font-medium text-foreground shadow-md backdrop-blur-sm">
        {labels[axis]}: {Math.round(dimension)}mm
      </div>
    </Html>
  );
}

// ============================================================================
// Main Component
// ============================================================================

export function CabinetResizeControls({
  cabinetId,
  onTransformStart,
  onTransformEnd,
}: CabinetResizeControlsProps) {
  const { camera, gl } = useThree();

  // Get cabinet
  const cabinet = useStore((state) =>
    state.cabinets.find((c) => c.id === cabinetId)
  );

  // Get cabinet parts
  const cabinetParts = useStore(
    useShallow((state) =>
      state.parts.filter((p) => p.cabinetMetadata?.cabinetId === cabinetId)
    )
  );

  // Get materials for generator
  const materials = useStore((state) => state.materials);

  // Store actions
  const {
    updateCabinetParams,
    setTransformingCabinetId,
    beginBatch,
    commitBatch,
    isShiftPressed,
  } = useStore(
    useShallow((state) => ({
      updateCabinetParams: state.updateCabinetParams,
      setTransformingCabinetId: state.setTransformingCabinetId,
      beginBatch: state.beginBatch,
      commitBatch: state.commitBatch,
      isShiftPressed: state.isShiftPressed,
    }))
  );

  // Local state
  const [hoveredHandle, setHoveredHandle] = useState<CabinetResizeHandle | null>(null);
  const [activeHandle, setActiveHandle] = useState<CabinetResizeHandle | null>(null);
  const [previewVersion, setPreviewVersion] = useState(0);

  // Calculate bounding box
  const boundingBox = useMemo(
    () => calculateCabinetBoundingBox(cabinetParts),
    [cabinetParts]
  );

  // Drag state ref
  const dragStateRef = useRef<DragState>({
    isDragging: false,
    handle: null,
    startPoint: new THREE.Vector3(),
    initialBoundingBox: boundingBox,
    initialCenter: new THREE.Vector3(),
    initialRotation: new THREE.Quaternion(),
    previewParts: [],
    previewBoundingBox: null,
    newParams: null,
    centerOffset: null,
  });

  // Drag plane and raycaster refs
  const dragPlaneRef = useRef(new THREE.Plane());
  const raycasterRef = useRef(new THREE.Raycaster());
  const intersectPointRef = useRef(new THREE.Vector3());
  const rafIdRef = useRef<number | null>(null);

  // Refs for stable access
  const cabinetRef = useRef(cabinet);
  const cabinetPartsRef = useRef(cabinetParts);
  const materialsRef = useRef(materials);
  const isShiftPressedRef = useRef(isShiftPressed);

  useEffect(() => { cabinetRef.current = cabinet; }, [cabinet]);
  useEffect(() => { cabinetPartsRef.current = cabinetParts; }, [cabinetParts]);
  useEffect(() => { materialsRef.current = materials; }, [materials]);
  useEffect(() => { isShiftPressedRef.current = isShiftPressed; }, [isShiftPressed]);

  // Cleanup RAF
  useEffect(() => {
    return () => {
      if (rafIdRef.current !== null) {
        cancelAnimationFrame(rafIdRef.current);
      }
    };
  }, []);

  // Handle pointer down
  const handlePointerDown = useCallback(
    (e: ThreeEvent<PointerEvent>, handle: CabinetResizeHandle) => {
      e.stopPropagation();

      if (!cabinet) return;

      const startPoint = e.point.clone();
      const currentBoundingBox = calculateCabinetBoundingBox(cabinetParts);
      const { center, rotation } = getCabinetTransform(cabinetParts);

      dragStateRef.current = {
        isDragging: true,
        handle,
        startPoint,
        initialBoundingBox: currentBoundingBox,
        initialCenter: center.clone(),
        initialRotation: rotation.clone(),
        previewParts: [],
        previewBoundingBox: null,
        newParams: null,
        centerOffset: null,
      };

      // Setup drag plane
      const cameraDir = new THREE.Vector3();
      camera.getWorldDirection(cameraDir);
      dragPlaneRef.current.setFromNormalAndCoplanarPoint(cameraDir, startPoint);

      // Begin history
      beginBatch('TRANSFORM_CABINET', {
        targetId: cabinetId,
        before: { params: cabinet.params },
      });

      setActiveHandle(handle);
      setTransformingCabinetId(cabinetId);
      onTransformStart();

      gl.domElement.setPointerCapture((e as unknown as { pointerId: number }).pointerId);
    },
    [cabinet, cabinetParts, camera, beginBatch, cabinetId, setTransformingCabinetId, onTransformStart, gl]
  );

  // Pointer move and up handlers
  useEffect(() => {
    const handlePointerMove = (e: PointerEvent) => {
      if (!dragStateRef.current.isDragging || !dragStateRef.current.handle) return;

      // RAF throttle
      if (rafIdRef.current !== null) return;

      rafIdRef.current = requestAnimationFrame(() => {
        rafIdRef.current = null;

        const cabinet = cabinetRef.current;
        if (!cabinet) return;

        // Raycast to drag plane
        const rect = gl.domElement.getBoundingClientRect();
        const x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
        const y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

        raycasterRef.current.setFromCamera(new THREE.Vector2(x, y), camera);
        raycasterRef.current.ray.intersectPlane(dragPlaneRef.current, intersectPointRef.current);

        if (!intersectPointRef.current) return;

        // Calculate drag offset
        let dragOffset: [number, number, number] = [
          intersectPointRef.current.x - dragStateRef.current.startPoint.x,
          intersectPointRef.current.y - dragStateRef.current.startPoint.y,
          intersectPointRef.current.z - dragStateRef.current.startPoint.z,
        ];

        // Grid snap
        if (isShiftPressedRef.current) {
          dragOffset = [
            Math.round(dragOffset[0] / GRID_SNAP) * GRID_SNAP,
            Math.round(dragOffset[1] / GRID_SNAP) * GRID_SNAP,
            Math.round(dragOffset[2] / GRID_SNAP) * GRID_SNAP,
          ];
        }

        const handle = dragStateRef.current.handle!;
        const axisIndex = getHandleAxisIndex(handle);
        const isPositive = isPositiveHandle(handle);
        const normal = getCabinetHandleNormal(handle);

        // Project drag onto handle normal
        const dragAlongAxis = dragOffset[0] * normal[0] + dragOffset[1] * normal[1] + dragOffset[2] * normal[2];

        // Calculate new dimension
        const initialBox = dragStateRef.current.initialBoundingBox;
        const oldDim = initialBox.size[axisIndex];
        const newDim = Math.max(MIN_DIMENSION, Math.round(oldDim + dragAlongAxis));
        const dimDelta = newDim - oldDim;

        // Create new params with updated dimension
        const newParams: CabinetParams = { ...cabinet.params };
        if (axisIndex === 0) newParams.width = newDim;
        else if (axisIndex === 1) newParams.height = newDim;
        else newParams.depth = newDim;

        // Get materials for generator
        const bodyMaterial = materialsRef.current.find((m) => m.id === cabinet.materials.bodyMaterialId);
        if (!bodyMaterial) return;

        const backMaterial = cabinet.materials.backMaterialId
          ? materialsRef.current.find((m) => m.id === cabinet.materials.backMaterialId)
          : getDefaultBackMaterial(materialsRef.current);

        // Generate preview parts with new dimensions
        const generator = getGeneratorForType(newParams.type);
        const generatedParts = generator(
          cabinetId,
          cabinet.furnitureId,
          newParams,
          cabinet.materials,
          bodyMaterial,
          backMaterial
        );

        // Calculate position offset so the fixed edge stays in place
        // When dragging positive handle, min edge stays fixed → center moves by delta/2 in positive direction
        // When dragging negative handle, max edge stays fixed → center moves by delta/2 in negative direction
        const positionOffset = new THREE.Vector3();
        if (isPositive) {
          positionOffset.setComponent(axisIndex, dimDelta / 2);
        } else {
          positionOffset.setComponent(axisIndex, -dimDelta / 2);
        }

        // Apply rotation to position offset (if cabinet is rotated)
        positionOffset.applyQuaternion(dragStateRef.current.initialRotation);

        // Calculate new center
        const newCenter = dragStateRef.current.initialCenter.clone().add(positionOffset);

        // Apply transform to generated parts
        const transformedParts = applyCabinetTransform(
          generatedParts,
          newCenter,
          dragStateRef.current.initialRotation
        );

        // Calculate preview bounding box
        const previewBoundingBox = calculateCabinetBoundingBox(transformedParts as Part[]);

        // Update drag state
        dragStateRef.current.previewParts = transformedParts;
        dragStateRef.current.previewBoundingBox = previewBoundingBox;
        dragStateRef.current.newParams = newParams;
        dragStateRef.current.centerOffset = positionOffset.toArray() as [number, number, number];

        // Trigger re-render
        setPreviewVersion((v) => v + 1);
      });
    };

    const handlePointerUp = () => {
      if (!dragStateRef.current.isDragging) return;

      // Cancel pending RAF
      if (rafIdRef.current !== null) {
        cancelAnimationFrame(rafIdRef.current);
        rafIdRef.current = null;
      }

      const cabinet = cabinetRef.current;
      const newParams = dragStateRef.current.newParams;
      const centerOffset = dragStateRef.current.centerOffset;

      if (cabinet && newParams) {
        // Update cabinet params with center offset (triggers regeneration at correct position)
        updateCabinetParams(cabinetId, newParams, true, centerOffset || undefined);

        // Commit history
        commitBatch({
          after: { params: newParams },
        });
      } else {
        commitBatch({
          after: { params: cabinet?.params },
        });
      }

      // Reset state
      dragStateRef.current.isDragging = false;
      dragStateRef.current.handle = null;
      dragStateRef.current.previewParts = [];
      dragStateRef.current.previewBoundingBox = null;
      dragStateRef.current.newParams = null;
      dragStateRef.current.centerOffset = null;

      setActiveHandle(null);
      setTransformingCabinetId(null);
      onTransformEnd();
    };

    window.addEventListener('pointermove', handlePointerMove);
    window.addEventListener('pointerup', handlePointerUp);

    return () => {
      window.removeEventListener('pointermove', handlePointerMove);
      window.removeEventListener('pointerup', handlePointerUp);
    };
  }, [camera, gl, cabinetId, updateCabinetParams, commitBatch, setTransformingCabinetId, onTransformEnd]);

  // Get preview state
  const isShowingPreview = activeHandle !== null && dragStateRef.current.previewParts.length > 0;
  const displayBoundingBox = isShowingPreview && dragStateRef.current.previewBoundingBox
    ? dragStateRef.current.previewBoundingBox
    : boundingBox;

  if (!cabinet || cabinetParts.length === 0) {
    return null;
  }

  return (
    <group>
      {/* Preview meshes during drag - generated by the same generator as final result */}
      {isShowingPreview && dragStateRef.current.previewParts.map((part, index) => (
        <PreviewMesh key={`preview-${index}-${previewVersion}`} part={part} />
      ))}

      {/* Resize handles */}
      {HANDLES.map((handle) => (
        <HandleMesh
          key={handle}
          boundingBox={displayBoundingBox}
          handle={handle}
          isActive={activeHandle === handle}
          isHovered={hoveredHandle === handle}
          onPointerDown={handlePointerDown}
          onPointerEnter={setHoveredHandle}
          onPointerLeave={() => setHoveredHandle(null)}
        />
      ))}

      {/* Dimension display */}
      {activeHandle && dragStateRef.current.previewBoundingBox && (
        <DimensionDisplay
          boundingBox={dragStateRef.current.previewBoundingBox}
          activeHandle={activeHandle}
        />
      )}
    </group>
  );
}
