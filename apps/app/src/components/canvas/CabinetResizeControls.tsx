"use client";

/**
 * CabinetResizeControls Component
 *
 * Renders 6 resize handles on cabinet bounding box.
 * Uses GENERATOR-BASED preview - same logic as PropertiesPanel for consistency.
 *
 * PERFORMANCE STRATEGY:
 * - dragStateRef stores mutable state during drag
 * - Generator creates preview parts with new dimensions
 * - RAF throttle ensures smooth updates
 * - Store updated ONCE on pointerup
 */

import { useRef, useCallback, useEffect, useState, useMemo } from "react";
import { useThree, ThreeEvent } from "@react-three/fiber";
import * as THREE from "three";
import { useStore, useMaterial } from "@/lib/store";
import { useShallow } from "zustand/react/shallow";
import { useHiddenResizeHandles } from "@/hooks/useOrthographicConstraints";
import type { Part, CabinetResizeHandle, CabinetParams } from "@/types";
import { PART_CONFIG, MATERIAL_CONFIG } from "@/lib/config";
import { getGeneratorForType } from "@/lib/cabinetGenerators";
import {
  getCabinetTransform,
  applyCabinetTransform,
  getDefaultBackMaterial,
} from "@/lib/store/utils";
import {
  calculateCabinetOBB,
  getOBBHandlePosition,
  getOBBHandleNormal,
  getHandleAxisIndex,
  isPositiveHandle,
  getHandleAxisName,
  type CabinetOBB,
} from "@/lib/cabinetResize";
import { ResizeHandleMesh, DimensionDisplay } from "./resize";

// ============================================================================
// Constants
// ============================================================================

const MIN_DIMENSION = 50;
const GRID_SNAP = 10;

const HANDLES: CabinetResizeHandle[] = [
  "width+",
  "width-",
  "height+",
  "height-",
  "depth+",
  "depth-",
];

// ============================================================================
// Types
// ============================================================================

interface CabinetResizeControlsProps {
  cabinetId: string;
  onTransformStart: () => void;
  onTransformEnd: () => void;
}

interface DragState {
  isDragging: boolean;
  handle: CabinetResizeHandle | null;
  startPoint: THREE.Vector3;
  initialOBB: CabinetOBB;
  initialCenter: THREE.Vector3;
  initialRotation: THREE.Quaternion;
  // Preview parts generated by the generator
  previewParts: Omit<Part, "id" | "createdAt" | "updatedAt">[];
  previewOBB: CabinetOBB | null;
  newParams: CabinetParams | null;
  centerOffset: [number, number, number] | null;
}

// ============================================================================
// Preview Mesh Component
// ============================================================================

interface PreviewMeshProps {
  part: Omit<Part, "id" | "createdAt" | "updatedAt">;
}

function PreviewMesh({ part }: PreviewMeshProps) {
  const material = useMaterial(part.materialId);
  const color = material?.color || MATERIAL_CONFIG.DEFAULT_MATERIAL_COLOR;

  return (
    <mesh position={part.position} rotation={part.rotation} castShadow receiveShadow>
      <boxGeometry args={[part.width, part.height, part.depth]} />
      <meshStandardMaterial
        color={color}
        emissive={PART_CONFIG.SELECTION_EMISSIVE_COLOR}
        emissiveIntensity={PART_CONFIG.SELECTION_EMISSIVE_INTENSITY}
      />
    </mesh>
  );
}

// ============================================================================
// Main Component
// ============================================================================

export function CabinetResizeControls({
  cabinetId,
  onTransformStart,
  onTransformEnd,
}: CabinetResizeControlsProps) {
  const { camera, gl } = useThree();

  // Get hidden handles for orthographic view
  const hiddenHandles = useHiddenResizeHandles();

  // Get cabinet
  const cabinet = useStore((state) => state.cabinets.find((c) => c.id === cabinetId));

  // Get cabinet parts
  const cabinetParts = useStore(
    useShallow((state) => state.parts.filter((p) => p.cabinetMetadata?.cabinetId === cabinetId))
  );

  // Get materials for generator
  const materials = useStore((state) => state.materials);

  // Store actions
  const { updateCabinetParams, setTransformingCabinetId, beginBatch, commitBatch, isShiftPressed } =
    useStore(
      useShallow((state) => ({
        updateCabinetParams: state.updateCabinetParams,
        setTransformingCabinetId: state.setTransformingCabinetId,
        beginBatch: state.beginBatch,
        commitBatch: state.commitBatch,
        isShiftPressed: state.isShiftPressed,
      }))
    );

  // Local state
  const [hoveredHandle, setHoveredHandle] = useState<CabinetResizeHandle | null>(null);
  const [activeHandle, setActiveHandle] = useState<CabinetResizeHandle | null>(null);
  const [previewVersion, setPreviewVersion] = useState(0);

  // Calculate OBB (oriented bounding box)
  const obb = useMemo(() => calculateCabinetOBB(cabinetParts), [cabinetParts]);

  // Drag state ref
  const dragStateRef = useRef<DragState>({
    isDragging: false,
    handle: null,
    startPoint: new THREE.Vector3(),
    initialOBB: obb,
    initialCenter: new THREE.Vector3(),
    initialRotation: new THREE.Quaternion(),
    previewParts: [],
    previewOBB: null,
    newParams: null,
    centerOffset: null,
  });

  // Drag plane and raycaster refs
  const dragPlaneRef = useRef(new THREE.Plane());
  const raycasterRef = useRef(new THREE.Raycaster());
  const intersectPointRef = useRef(new THREE.Vector3());
  const rafIdRef = useRef<number | null>(null);

  // Refs for stable access
  const cabinetRef = useRef(cabinet);
  const cabinetPartsRef = useRef(cabinetParts);
  const materialsRef = useRef(materials);
  const isShiftPressedRef = useRef(isShiftPressed);

  useEffect(() => {
    cabinetRef.current = cabinet;
  }, [cabinet]);
  useEffect(() => {
    cabinetPartsRef.current = cabinetParts;
  }, [cabinetParts]);
  useEffect(() => {
    materialsRef.current = materials;
  }, [materials]);
  useEffect(() => {
    isShiftPressedRef.current = isShiftPressed;
  }, [isShiftPressed]);

  // Cleanup RAF
  useEffect(() => {
    return () => {
      if (rafIdRef.current !== null) {
        cancelAnimationFrame(rafIdRef.current);
      }
    };
  }, []);

  // Handle pointer down
  const handlePointerDown = useCallback(
    (e: ThreeEvent<PointerEvent>, handle: CabinetResizeHandle) => {
      e.stopPropagation();

      if (!cabinet) return;

      const startPoint = e.point.clone();
      const currentOBB = calculateCabinetOBB(cabinetParts);
      const { center, rotation } = getCabinetTransform(cabinetParts);

      dragStateRef.current = {
        isDragging: true,
        handle,
        startPoint,
        initialOBB: currentOBB,
        initialCenter: center.clone(),
        initialRotation: rotation.clone(),
        previewParts: [],
        previewOBB: null,
        newParams: null,
        centerOffset: null,
      };

      // Setup drag plane
      const cameraDir = new THREE.Vector3();
      camera.getWorldDirection(cameraDir);
      dragPlaneRef.current.setFromNormalAndCoplanarPoint(cameraDir, startPoint);

      // Begin history
      beginBatch("TRANSFORM_CABINET", {
        targetId: cabinetId,
        before: { params: cabinet.params },
      });

      setActiveHandle(handle);
      setTransformingCabinetId(cabinetId);
      onTransformStart();

      gl.domElement.setPointerCapture((e as unknown as { pointerId: number }).pointerId);
    },
    [
      cabinet,
      cabinetParts,
      camera,
      beginBatch,
      cabinetId,
      setTransformingCabinetId,
      onTransformStart,
      gl,
    ]
  );

  // Pointer move and up handlers
  useEffect(() => {
    const handlePointerMove = (e: PointerEvent) => {
      if (!dragStateRef.current.isDragging || !dragStateRef.current.handle) return;

      // RAF throttle
      if (rafIdRef.current !== null) return;

      rafIdRef.current = requestAnimationFrame(() => {
        rafIdRef.current = null;

        const cabinet = cabinetRef.current;
        if (!cabinet) return;

        // Raycast to drag plane
        const rect = gl.domElement.getBoundingClientRect();
        const x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
        const y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

        raycasterRef.current.setFromCamera(new THREE.Vector2(x, y), camera);
        raycasterRef.current.ray.intersectPlane(dragPlaneRef.current, intersectPointRef.current);

        if (!intersectPointRef.current) return;

        // Calculate drag offset
        let dragOffset: [number, number, number] = [
          intersectPointRef.current.x - dragStateRef.current.startPoint.x,
          intersectPointRef.current.y - dragStateRef.current.startPoint.y,
          intersectPointRef.current.z - dragStateRef.current.startPoint.z,
        ];

        // Grid snap
        if (isShiftPressedRef.current) {
          dragOffset = [
            Math.round(dragOffset[0] / GRID_SNAP) * GRID_SNAP,
            Math.round(dragOffset[1] / GRID_SNAP) * GRID_SNAP,
            Math.round(dragOffset[2] / GRID_SNAP) * GRID_SNAP,
          ];
        }

        const handle = dragStateRef.current.handle!;
        const axisIndex = getHandleAxisIndex(handle);
        const isPositive = isPositiveHandle(handle);
        const initialOBB = dragStateRef.current.initialOBB;
        const normal = getOBBHandleNormal(initialOBB, handle);

        // Project drag onto handle normal (in world space)
        const dragAlongAxis =
          dragOffset[0] * normal[0] + dragOffset[1] * normal[1] + dragOffset[2] * normal[2];

        // Calculate new dimension
        const oldDim = initialOBB.size[axisIndex];
        const newDim = Math.max(MIN_DIMENSION, Math.round(oldDim + dragAlongAxis));
        const dimDelta = newDim - oldDim;

        // Create new params with updated dimension
        const newParams: CabinetParams = { ...cabinet.params };
        if (axisIndex === 0) newParams.width = newDim;
        else if (axisIndex === 1) newParams.height = newDim;
        else newParams.depth = newDim;

        // Get materials for generator
        const bodyMaterial = materialsRef.current.find(
          (m) => m.id === cabinet.materials.bodyMaterialId
        );
        if (!bodyMaterial) return;

        const backMaterial = cabinet.materials.backMaterialId
          ? materialsRef.current.find((m) => m.id === cabinet.materials.backMaterialId)
          : getDefaultBackMaterial(materialsRef.current);

        // Generate preview parts with new dimensions
        const generator = getGeneratorForType(newParams.type);
        const generatedParts = generator(
          cabinetId,
          cabinet.furnitureId,
          newParams,
          cabinet.materials,
          bodyMaterial,
          backMaterial
        );

        // Calculate position offset so the fixed edge stays in place
        // When dragging positive handle, min edge stays fixed → center moves by delta/2 in positive direction
        // When dragging negative handle, max edge stays fixed → center moves by delta/2 in negative direction
        const positionOffset = new THREE.Vector3();
        if (isPositive) {
          positionOffset.setComponent(axisIndex, dimDelta / 2);
        } else {
          positionOffset.setComponent(axisIndex, -dimDelta / 2);
        }

        // Apply rotation to position offset (if cabinet is rotated)
        positionOffset.applyQuaternion(dragStateRef.current.initialRotation);

        // Calculate new center
        const newCenter = dragStateRef.current.initialCenter.clone().add(positionOffset);

        // Apply transform to generated parts
        const transformedParts = applyCabinetTransform(
          generatedParts,
          newCenter,
          dragStateRef.current.initialRotation
        );

        // Calculate preview OBB
        const previewOBB = calculateCabinetOBB(transformedParts as Part[]);

        // Update drag state
        dragStateRef.current.previewParts = transformedParts;
        dragStateRef.current.previewOBB = previewOBB;
        dragStateRef.current.newParams = newParams;
        dragStateRef.current.centerOffset = positionOffset.toArray() as [number, number, number];

        // Trigger re-render
        setPreviewVersion((v) => v + 1);
      });
    };

    const handlePointerUp = () => {
      if (!dragStateRef.current.isDragging) return;

      // Cancel pending RAF
      if (rafIdRef.current !== null) {
        cancelAnimationFrame(rafIdRef.current);
        rafIdRef.current = null;
      }

      const cabinet = cabinetRef.current;
      const newParams = dragStateRef.current.newParams;
      const centerOffset = dragStateRef.current.centerOffset;

      if (cabinet && newParams) {
        // Update cabinet params with center offset (triggers regeneration at correct position)
        updateCabinetParams(cabinetId, newParams, true, centerOffset || undefined);

        // Commit history
        commitBatch({
          after: { params: newParams },
        });
      } else {
        commitBatch({
          after: { params: cabinet?.params },
        });
      }

      // Reset state
      dragStateRef.current.isDragging = false;
      dragStateRef.current.handle = null;
      dragStateRef.current.previewParts = [];
      dragStateRef.current.previewOBB = null;
      dragStateRef.current.newParams = null;
      dragStateRef.current.centerOffset = null;

      setActiveHandle(null);
      setTransformingCabinetId(null);
      onTransformEnd();
    };

    window.addEventListener("pointermove", handlePointerMove);
    window.addEventListener("pointerup", handlePointerUp);

    return () => {
      window.removeEventListener("pointermove", handlePointerMove);
      window.removeEventListener("pointerup", handlePointerUp);
    };
  }, [
    camera,
    gl,
    cabinetId,
    updateCabinetParams,
    commitBatch,
    setTransformingCabinetId,
    onTransformEnd,
  ]);

  // Get preview state
  const isShowingPreview = activeHandle !== null && dragStateRef.current.previewParts.length > 0;
  const displayOBB =
    isShowingPreview && dragStateRef.current.previewOBB ? dragStateRef.current.previewOBB : obb;

  // Get dimension info for active handle - must be before early return
  const activeDimensionInfo = useMemo(() => {
    if (!activeHandle || !dragStateRef.current.previewOBB) return null;
    const axis = getHandleAxisName(activeHandle);
    const axisIndex = getHandleAxisIndex(activeHandle);
    const dimension = dragStateRef.current.previewOBB.size[axisIndex];
    const pos = getOBBHandlePosition(dragStateRef.current.previewOBB, activeHandle);
    return {
      axis,
      dimension,
      position: [pos[0], pos[1] + 40, pos[2]] as [number, number, number],
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [activeHandle, previewVersion]);

  // Filter handles for orthographic view
  const visibleHandles = useMemo(() => {
    return HANDLES.filter((handle) => !hiddenHandles.includes(handle));
  }, [hiddenHandles]);

  if (!cabinet || cabinetParts.length === 0) {
    return null;
  }

  return (
    <group>
      {/* Preview meshes during drag - generated by the same generator as final result */}
      {isShowingPreview &&
        dragStateRef.current.previewParts.map((part, index) => (
          <PreviewMesh key={`preview-${index}-${previewVersion}`} part={part} />
        ))}

      {/* Resize handles */}
      {visibleHandles.map((handle) => {
        const position = getOBBHandlePosition(displayOBB, handle);
        const normal = getOBBHandleNormal(displayOBB, handle);
        return (
          <ResizeHandleMesh
            key={handle}
            position={position}
            normal={normal}
            handleId={handle}
            isDragging={activeHandle === handle}
            isHovered={hoveredHandle === handle}
            onPointerDown={(e, id) => handlePointerDown(e, id as CabinetResizeHandle)}
            onPointerEnter={(id) => setHoveredHandle(id as CabinetResizeHandle)}
            onPointerLeave={() => setHoveredHandle(null)}
          />
        );
      })}

      {/* Dimension display */}
      {activeDimensionInfo && (
        <DimensionDisplay
          position={activeDimensionInfo.position}
          dimension={activeDimensionInfo.dimension}
          axis={activeDimensionInfo.axis}
        />
      )}
    </group>
  );
}
